# Tasks – First-Run Experience and Config Reliability

**Date:** 2026-01-24
**Related Research:** `memory-bank/research/2026-01-24_15-32-00_first-run-config-broken.md`

## Task Order Logic

Tasks are ordered by dependency - complete tasks in this order:
- **Critical crash blockers first** (users can't use the app)
- **Enable recovery mechanisms** (allow users to fix issues)
- **Improve UX and reliability** (prevent future issues)

---

## Phase 1: Critical Crash Blockers

### Task 1: Lazy-initialize StateManager (BLOCKER)
**Status:** TODO
**Priority:** CRITICAL
**Location:** `src/tunacode/ui/main.py:25`

**Problem:** Module-level `state_manager = StateManager()` runs at import time, so any config error crashes before CLI args like `--setup` are even parsed.

**Why first:** This blocks ALL other fixes. Users can't run `--setup` to fix config because the crash happens first.

**Action:**
```python
# main.py:25 - BEFORE
state_manager = StateManager()

# AFTER
_state_manager: StateManager | None = None

def get_state_manager() -> StateManager:
    global _state_manager
    if _state_manager is None:
        _state_manager = StateManager()
    return _state_manager
```

**Update all imports:** Replace direct `state_manager` usage with `get_state_manager()` calls.

**Verification:** Run `tunacode --setup` with empty config - should not crash before parsing args.

**Blocks:** Tasks 2, 3, 4, 5, 6

---

### Task 2: Handle empty config file gracefully (BLOCKER)
**Status:** TODO
**Priority:** CRITICAL
**Location:** `src/tunacode/utils/config/user_configuration.py:32-34`

**Problem:** Empty config file (`""`) causes `JSONDecodeError` at char 0, which raises `ConfigurationError` instead of falling back to defaults.

**Why second:** Once Task 1 allows `--setup` to run, we need it to actually work with empty config files.

**Action:**
```python
# user_configuration.py - ADD to JSONDecodeError handler
except JSONDecodeError as err:
    # Check if file is empty - treat same as missing file
    if err.pos == 0:
        return None
    msg = f"Invalid JSON in config file at {app_settings.paths.config_file}"
    raise ConfigurationError(msg) from err
```

**Verification:**
1. Create empty config: `touch ~/.config/tunacode.json`
2. Run: `tunacode --setup`
3. Should: Open setup wizard, not crash

**Blocks:** Tasks 3, 4, 5

**Depends on:** Task 1

---

### Task 3: Add graceful degradation to config loading (BLOCKER)
**Status:** TODO
**Priority:** CRITICAL
**Location:** `src/tunacode/utils/config/user_configuration.py` + 4 call sites

**Problem:** `load_config()` raises `ConfigurationError` but ALL 4 callers assume it only returns `UserConfig | None` and don't catch exceptions.

**Why third:** Even after Tasks 1-2, any other config error (malformed JSON, permissions) will still crash. Need to ensure config loading NEVER raises to callers.

**Action A:** Change `load_config()` to NEVER raise
```python
def load_config() -> UserConfig | None:
    """
    Load user config from file.
    Returns None for any error (missing, empty, invalid format, permissions).
    """
    try:
        path = app_settings.paths.config_file
        if not path.exists():
            return None
        with open(path) as f:
            content = f.read()
            if not content.strip():
                return None
            data = json.loads(content)
            if not isinstance(data, dict):
                return None
            return cast(UserConfig, data)
    except (FileNotFoundError, JSONDecodeError, OSError, Exception):
        # Return None for ANY error - caller uses defaults
        return None
```

**Action B:** Verify all 4 callers handle None correctly
- `state.py:150` - OK (has fallback)
- `agent_config.py:250` - Verify
- `limits.py:31` - Verify
- `decorators.py:52` - OK (uses `or {}`)

**Verification:**
- Create malformed JSON: `echo "not json" > ~/.config/tunacode.json`
- Run: `tunacode --setup`
- Should: Open setup wizard with defaults, not crash

**Blocks:** Tasks 4, 5

**Depends on:** Task 2

---

## Phase 2: Enable Recovery

### Task 4: Make --setup resilient to corrupted config
**Status:** TODO
**Priority:** HIGH
**Location:** `src/tunacode/ui/main.py` + CLI arg parsing

**Problem:** Even with graceful degradation, setup wizard needs to handle corrupted configs gracefully and provide clear guidance.

**Why fourth:** Now that `--setup` can run without crashing, we need to ensure it actually helps users recover from config issues.

**Action:**
1. Add CLI validation in setup flow
2. Show warning if config is corrupted/invalid
3. Offer to reset to defaults

**Verification:**
- Run: `tunacode --setup` with various corrupt states
- Should: Show helpful warning, offer reset

**Blocks:** Task 5

**Depends on:** Task 3

---

### Task 5: Create config file on first-run
**Status:** TODO
**Priority:** HIGH
**Location:** `src/tunacode/core/state.py:164-165`

**Problem:** Config file is never created on first-run. Users run with in-memory defaults that are never written to disk.

**Why fifth:** Once config loading is resilient, we can safely create defaults on first-run without risk of crashes.

**Action:**
```python
# state.py:164-165
else:
    # No user config file found, use defaults and create file
    self._session.user_config = DEFAULT_USER_CONFIG.copy()
    from tunacode.utils.config import save_config
    save_config(self)  # ← Create config file
```

**Verification:**
1. Remove existing config: `rm ~/.config/tunacode.json`
2. Run: `tunacode` (no args)
3. Should: Create `~/.config/tunacode.json` with defaults

**Blocks:** Task 6, 7

**Depends on:** Task 3

---

## Phase 3: Improve UX

### Task 6: Add API key validation in setup
**Status:** TODO
**Priority:** MEDIUM
**Location:** `src/tunacode/ui/screens/setup.py:191-193`

**Problem:** No validation on API key input - accepts garbage strings which get stored as-is.

**Why sixth:** Prevent user error from corrupting config like the Chutes issue.

**Action:**
```python
# setup.py:191-193 - REPLACE
if not api_key:
    error_label.update("API key is required")
    return

# Add validation
# Check for JSON-like characters (indicates bad copy-paste)
if any(c in api_key for c in ['{', '}', '":"']):
    error_label.update("API key appears malformed - check you copied only the key")
    return

# Check reasonable length (most keys are 16-128 chars)
if len(api_key) < 10 or len(api_key) > 256:
    error_label.update("API key length seems wrong - check your key")
    return
```

**Verification:**
- Run `tunacode --setup`
- Paste garbage like: `{ "CHUTES_API_KEY": "\"base_url\": \"...\" }`
- Should: Show validation error, prevent save

**Depends on:** Task 5

---

## Phase 4: Design Cleanup

### Task 7: Consolidate config paths
**Status:** TODO
**Priority:** MEDIUM
**Location:** Multiple files

**Problem:** User data scattered across 3 locations:
- Config: `~/.config/tunacode.json`
- Device ID: `~/.tunacode/`
- Sessions: BOTH `~/.tunacode/sessions/` AND `~/.local/share/tunacode/sessions/`

**Why seventh:** Nice-to-have cleanup, not blocking anything. Improves maintainability.

**Action:**
1. Decide on ONE location (XDG compliant: `~/.config/` for config, `~/.local/share/` for data)
2. Update `settings.py:16` to use consistent path
3. Update `paths.py` to use consistent locations
4. Add migration logic if needed for existing users

**Decision needed:**
- Option A: Full XDG compliance (`~/.config/`, `~/.local/share/`)
- Option B: Single directory (`~/.tunacode/` everything)

**Verification:**
- Run app with fresh install
- Confirm all data in single hierarchy
- Test migration from old paths

**Depends on:** None (can be done anytime)

---

## Summary

| Task | Priority | Phase | Blocks | Depends On |
|------|----------|-------|--------|------------|
| 1. Lazy StateManager | CRITICAL | 1 | 2,3,4,5,6 | - |
| 2. Empty config handling | CRITICAL | 1 | 3,4,5 | 1 |
| 3. Graceful degradation | CRITICAL | 1 | 4,5 | 2 |
| 4. --setup resilience | HIGH | 2 | 5 | 3 |
| 5. Config on first-run | HIGH | 2 | 6 | 3 |
| 6. API key validation | MEDIUM | 3 | - | 5 |
| 7. Consolidate paths | MEDIUM | 4 | - | - |

**Critical path:** 1 → 2 → 3 → 5 → 6

**Minimum viable fix:** Tasks 1-3 only (stops crashes, allows recovery)

**Full fix:** All tasks (complete reliability and UX improvements)
