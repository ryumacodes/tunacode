# Research â€“ Web Fetch Tool Implementation

**Date:** 2025-12-09
**Owner:** claude
**Phase:** Research
**git_commit:** afff495
**tags:** tools, web, http, fetch, networking

## Goal

Research how to implement a web fetch tool in tunacode, drawing inspiration from OpenCode's implementation while adapting to tunacode's existing patterns.

## Findings

### Relevant files & why they matter:

**Tool Infrastructure:**
- `src/tunacode/tools/decorators.py:22-96` - `@base_tool` and `@file_tool` decorators for error handling
- `src/tunacode/tools/xml_helper.py:10-29` - XML prompt loading for tool descriptions
- `src/tunacode/core/agents/agent_components/agent_config.py:346-360` - Tool registration with pydantic-ai
- `src/tunacode/constants.py:46-57` - `ToolName` enum and tool classification lists

**Existing Tool Examples:**
- `src/tunacode/tools/bash.py` - Security validation pattern with dangerous pattern checking
- `src/tunacode/tools/read_file.py` - sync-to-async pattern with `asyncio.to_thread`
- `src/tunacode/tools/grep.py` - ThreadPoolExecutor for parallel work

**Configuration:**
- `src/tunacode/configuration/defaults.py` - `DEFAULT_USER_CONFIG` structure for feature flags
- `src/tunacode/types.py:29,57-58` - Type definitions for tools

**Dependencies (pyproject.toml):**
- `httpx` (v0.28.1) - Already used as primary HTTP client
- `markdown-it-py` (v4.0.0) - Available for markdown processing
- `defusedxml` - Available for safe XML parsing

### OpenCode Reference (provided by user):

OpenCode implements web tools with:
1. **WebFetch**: Direct HTTP fetch using native `fetch` API, 5MB limit, 120s timeout, HTML-to-markdown conversion
2. **WebSearch**: Uses Exa AI public MCP endpoint (no API key required)
3. **Permission control**: `webfetch` permission setting ("allow", "ask", "deny")

## Key Patterns / Solutions Found

### 1. Tool Creation Pattern in Tunacode

```python
# src/tunacode/tools/{tool_name}.py
from tunacode.tools.decorators import base_tool
from pydantic_ai.exceptions import ModelRetry

@base_tool
async def tool_name(param: str, optional_param: int = 10) -> str:
    """Description (overridden by XML prompt if exists)."""
    # Validate inputs
    if not param:
        raise ModelRetry("param cannot be empty")

    # Implementation
    result = do_work(param)
    return str(result)
```

### 2. Error Handling Hierarchy

- `ModelRetry` - Recoverable errors (bad URL format, temporary failures) - LLM can retry
- `ToolExecutionError` - Generic tool failures
- `@base_tool` automatically wraps uncaught exceptions as `ToolExecutionError`

### 3. Registration Steps

1. Create tool function in `src/tunacode/tools/web_fetch.py`
2. Create XML prompt in `src/tunacode/tools/prompts/web_fetch_prompt.xml`
3. Add import and `Tool()` wrapper to `agent_config.py` tools_list
4. Add `WEB_FETCH = "web_fetch"` to `ToolName` enum in `constants.py`
5. Optionally add to `READ_ONLY_TOOLS` list (since it doesn't modify filesystem)

### 4. HTTP Client Pattern (from agent_config.py)

```python
import httpx

async with httpx.AsyncClient(timeout=30) as client:
    response = await client.get(url)
    response.raise_for_status()
    content = response.text
```

### 5. Security Validation Pattern (from bash.py)

```python
DANGEROUS_URL_PATTERNS = [
    r"file://",           # Local file access
    r"localhost",         # Local services
    r"127\.0\.0\.1",      # Loopback
    r"0\.0\.0\.0",        # All interfaces
    r"192\.168\.",        # Private networks
    r"10\.\d+\.",         # Private networks
    r"172\.1[6-9]\.",     # Private networks
]

def _validate_url_security(url: str) -> None:
    for pattern in DANGEROUS_URL_PATTERNS:
        if re.search(pattern, url, re.IGNORECASE):
            raise ModelRetry(f"URL blocked for security: {pattern}")
```

## Knowledge Gaps

1. **HTML-to-Markdown**: No HTML parsing library currently installed
   - Options: `beautifulsoup4`, `html2text`, `markdownify`
   - Need to add as dependency or implement simple regex-based extraction

2. **Content Size Limits**: No established pattern for large response handling
   - OpenCode uses 5MB limit - sensible default

3. **Rate Limiting**: No pattern for external API rate limiting
   - May need simple backoff for repeated requests

4. **Caching**: No cache pattern exists in tools
   - OpenCode mentions 15-minute cache
   - Could use simple LRU cache with TTL

5. **Web Search**: Would require external API (Exa, SerpAPI, etc.)
   - Separate concern from basic fetch

## Proposed Implementation Structure

```
src/tunacode/tools/
    web_fetch.py           # Main tool implementation
    prompts/
        web_fetch_prompt.xml

src/tunacode/tools/utils/
    html_converter.py      # HTML-to-text/markdown conversion
    url_validator.py       # URL security validation
```

## Configuration Options Needed

```python
"settings": {
    "web_fetch": {
        "enabled": True,
        "max_size_bytes": 5_000_000,     # 5MB
        "timeout_seconds": 60,
        "convert_html_to_markdown": True,
        "blocked_domains": [],            # User-specified blocks
    },
}
```

## Dependencies to Add

**Required:**
- None (httpx already available)

**Recommended for HTML conversion:**
- `html2text` - Simple HTML-to-markdown conversion
- OR `beautifulsoup4` + `lxml` - Full HTML parsing (heavier)

## References

- OpenCode WebFetch: `packages/opencode/src/tool/webfetch.ts`
- OpenCode WebSearch: `packages/opencode/src/tool/websearch.ts`
- Tunacode tool docs: `docs/tools/architecture.md`
- Pydantic-ai Tool wrapper: https://ai.pydantic.dev/tools/
