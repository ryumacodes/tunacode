---
title: "LSP Detection Integration - Plan"
phase: Plan
date: "2025-12-17T12:00:00"
owner: "Planning Agent"
parent_research: "memory-bank/research/2025-12-17_11-35-51_lsp-detection-tunacode.md"
git_commit_at_plan: "5047a4e"
tags: [plan, lsp, diagnostics, tool-integration]
---

## Goal

Implement a simplified LSP client (~200 lines) that provides automatic diagnostic feedback to the AI agent after file modifications, supporting Python, TypeScript, Go, and Rust through a unified protocol.

**Non-goals:**
- Full IDE features (hover, completion, rename)
- Debouncing, caching, or advanced sync (add later)
- Auto-downloading language servers

## Scope & Assumptions

**In Scope:**
- Minimal LSP client with JSON-RPC over stdin/stdout
- Server spawn/lifecycle for pyright, typescript-language-server, gopls, rust-analyzer
- Decorator-level injection into `@file_tool`
- Config toggle (`settings.lsp.enabled`)
- Graceful degradation when servers unavailable

**Out of Scope:**
- UI indicators for LSP status (Phase 4 optional)
- Incremental document sync
- Multi-project root handling

**Assumptions:**
- Language servers are already installed on user's system
- Projects have standard structure (single root)
- pydantic-ai tool result flow remains unchanged

## Deliverables (Definition of Done)

1. **LSP Module** - `src/tunacode/lsp/` with client, servers, orchestrator
2. **Tool Integration** - `@file_tool` decorator injects diagnostics
3. **Config Support** - `settings.lsp.enabled` toggle
4. **Graceful Fallback** - Edit tools work even if LSP fails

**Acceptance Criteria:**
- `update_file` returns diagnostics in `<file_diagnostics>` block when errors exist
- Missing server = silent fallback, edit succeeds
- Config `lsp.enabled: false` = no LSP behavior

## Readiness (Definition of Ready)

- [x] Research document complete with architecture decision
- [x] Key files identified (decorators.py, update_file.py, write_file.py)
- [x] Server commands known (pyright, typescript-language-server, gopls, rust-analyzer)
- [ ] Dev environment has at least one language server installed (pyright recommended)

## Milestones

### M1: Core LSP Client
Create minimal LSP client that can spawn a server, initialize, and receive diagnostics.

### M2: Tool Integration
Wire LSP into `@file_tool` decorator so diagnostics appear in tool output.

### M3: Configuration & Polish
Add config toggle and handle edge cases gracefully.

## Work Breakdown (Tasks)

### M1 Tasks

| ID | Task | Dependencies | Files |
|----|------|--------------|-------|
| T1 | Create `src/tunacode/lsp/__init__.py` - orchestrator with `get_diagnostics(filepath)` | None | `lsp/__init__.py` |
| T2 | Create `src/tunacode/lsp/servers.py` - extension-to-command mapping | None | `lsp/servers.py` |
| T3 | Create `src/tunacode/lsp/client.py` - JSON-RPC client with initialize/didOpen/publishDiagnostics | T1, T2 | `lsp/client.py` |

**T3 Acceptance Tests:**
- Can spawn pyright-langserver subprocess
- Can send/receive JSON-RPC messages
- Receives diagnostics after didOpen with syntax error

### M2 Tasks

| ID | Task | Dependencies | Files |
|----|------|--------------|-------|
| T4 | Modify `@file_tool` decorator to call `get_diagnostics()` after file mods | T3 | `tools/decorators.py` |
| T5 | Format diagnostics as `<file_diagnostics>` XML block | T4 | `lsp/__init__.py` |

**T4 Acceptance Tests:**
- `update_file` on .py file with error returns diagnostics block
- `update_file` on file with no errors returns no diagnostics block
- Timeout after 5s, returns result without diagnostics

### M3 Tasks

| ID | Task | Dependencies | Files |
|----|------|--------------|-------|
| T6 | Add `lsp.enabled` to configuration defaults | None | `configuration/defaults.py` |
| T7 | Add server availability check with graceful fallback | T3 | `lsp/client.py` |
| T8 | Add timeout handling for slow servers | T3 | `lsp/client.py` |

**T6 Acceptance Tests:**
- `settings.lsp.enabled: false` = no LSP calls made
- `settings.lsp.enabled: true` = LSP calls made

## Risks & Mitigations

| Risk | Impact | Likelihood | Mitigation | Trigger |
|------|--------|------------|------------|---------|
| Language server not installed | Medium | High | Silent fallback, log warning | Server spawn fails |
| JSON-RPC parsing complexity | Medium | Medium | Use stdlib json, keep protocol minimal | Message parse errors |
| Server hangs on init | High | Low | 5s timeout on all operations | Timeout hit |
| Diagnostic flood | Low | Medium | Limit to 20 errors, filter by severity | Too many diagnostics |

## Test Strategy

**One Test (as specified):**

Create `tests/test_lsp_client.py` with a single integration test:

```python
async def test_lsp_client_receives_diagnostics():
    """Test that LSP client can spawn pyright and receive diagnostics for a file with errors."""
    # 1. Create temp .py file with syntax error
    # 2. Call get_diagnostics(filepath)
    # 3. Assert diagnostics list is non-empty
    # 4. Assert first diagnostic has line number and message
```

Skip if pyright not installed (pytest.mark.skipif).

## References

- Research: `memory-bank/research/2025-12-17_11-35-51_lsp-detection-tunacode.md`
- Key injection point: `src/tunacode/tools/decorators.py:59-96`
- Subprocess pattern: `src/tunacode/tools/bash.py:67-76`
- Configuration: `src/tunacode/configuration/defaults.py`
- Opencode reference: `packages/opencode/src/lsp/client.ts`

---

## Implementation Notes for Next Dev

### Client.py Core Structure

```python
# lsp/client.py - ~150 lines
class LSPClient:
    def __init__(self, command: list[str], root: Path):
        self.process: asyncio.subprocess.Process | None = None
        self.command = command
        self.root = root
        self._request_id = 0
        self._diagnostics: dict[str, list[Diagnostic]] = {}

    async def start(self) -> None:
        self.process = await asyncio.create_subprocess_exec(
            *self.command,
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            cwd=self.root,
        )
        await self._initialize()

    async def _send(self, method: str, params: dict) -> int:
        # JSON-RPC format: Content-Length: N\r\n\r\n{...}
        ...

    async def _receive(self) -> dict:
        # Read Content-Length header, then body
        ...

    async def open_file(self, path: Path, content: str) -> None:
        await self._send("textDocument/didOpen", {
            "textDocument": {
                "uri": f"file://{path}",
                "languageId": self._language_id(path),
                "version": 1,
                "text": content,
            }
        })

    async def get_diagnostics(self, path: Path, timeout: float = 5.0) -> list[Diagnostic]:
        # Wait for publishDiagnostics notification
        ...
```

### Decorator Integration Pattern

```python
# In decorators.py @file_tool wrapper
result = await func(filepath, *args, **kwargs)
if lsp_enabled():
    try:
        diagnostics = await asyncio.wait_for(
            get_diagnostics(Path(filepath)),
            timeout=5.0
        )
        if diagnostics:
            result += format_diagnostics(diagnostics)
    except Exception:
        pass  # Graceful degradation
return result
```

### Diagnostic Format

```xml
<file_diagnostics>
Error (line 15): Missing return statement
Error (line 23): Cannot find name 'undefined_var'
Warning (line 42): 'unused_import' is defined but never used
</file_diagnostics>
```

---

## Summary

**What:** Add LSP diagnostic feedback to file editing tools.

**Why:** Agent sees errors immediately, can self-correct without manual lint commands.

**How:**
1. Create minimal LSP client (~150 lines) with JSON-RPC over stdio
2. Wire into `@file_tool` decorator
3. Format diagnostics as XML block in tool output
4. Graceful fallback if server unavailable

**Tasks in Order:**
1. T1: Create `lsp/__init__.py` orchestrator
2. T2: Create `lsp/servers.py` extension mapping
3. T3: Create `lsp/client.py` JSON-RPC client
4. T4: Modify `@file_tool` decorator
5. T5: Format diagnostics output
6. T6: Add config toggle
7. T7: Add server availability check
8. T8: Add timeout handling

**One Test:** Integration test with pyright, skip if not installed.
